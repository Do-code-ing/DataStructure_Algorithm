어떤 알고리즘에 대한 두 가지 중요한 질문
    - 정확한가? 모든 입력 사례에 대해서 해답을 찾을 수 있는가? (correct)
    - 효율적인가? 입력 크기가 커지면 성능이 어떻게 변화하는가? (efficient)

알고리즘의 분석
    - 정확성 분석: 모든 입력 사례에 대해서 정확한 해답을 찾는다는 것을 증명 (ex)귀납적 증명)
    - 효율성 분석: 입력 크기가 커지는 정도에 따라 성능의 변화량을 증명
        - 시간 복잡도(time complexity): 시간을 기준으로 알고리즘의 효율성 분석 # 대부분 시간 복잡도 위주로 짠다.
        - 공간 복잡도(space complexity): 공간을 기준으로 알고리즘의 효율성 분석 # 빅데이터 분야 등에서 중요하다.

알고리즘의 성능 분석
    - 퍼포먼스 측정: 실행 시간을 직접 측정 or 실행 명령의 숫자 세기
        - 컴퓨터의 성능이다 프로그래밍 언어에 따라 달라짐 # 즉, 적절하지 않은 방법
    - 복잡도 분석: 컴퓨터나 프로그래밍 언어와 무관하게 성능 분석
        - 입력 크기에 따른 단위 연산의 실행 횟수 세기

복잡도 분석
    - 입력 크기: 문제가 가진 파라미터, 즉, 입력 사례의 크기
    - 단위 연산: 알고리즘 실행의 기본이 되는 명령어들의 집합
    
1.2(배열 원소의 합)의 시간 복잡도 분석
    
    def sum(n, S):
    result = 0
    for i in range(1, n+1):
        result = result + S[i]
    return result

    - 단위 연산: 리스트의 원소를 result에 더하는 명령
    - 입력 크기: 리스트 S의 원소 개수(n)
    - for 문장은 항상 n번 실행하므로 다음과 같이 표현
        - 시간 복잡도 T(n) = n

1.3(교환 정렬)의 시간 복잡도 분석

    def exchange(n, S):
    for i in range(1, n):
        for j in range(i+1, n+1):
            if S[i] > S[j]:
                S[i], S[j] = S[j], S[i] # swap

    - 단위 연산: S[i]와 S[j]의 비교
    - 입력 크기: 정렬할 리스트의 원소 개수(n)
    - for-j 루프는 i에 따라 n-1 번에서 1 번까지 실행하므로 다음과 같이 계산
    - 시간 복잡도: T(n) = (n-1) + (n-2) + ... + 1 = (n-1)n/2 = n**2/2 - n/2

1.4(행렬 곱셈)의 시간 복잡도 분석

    def matrixmult(A, B):
    n = len(A)
    C = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            for k in range(n):
                C[i][j] += A[i][k] * B[k][j]
    return C

    - 단위 연산: 가장 안쪽 for 루프에 있는 곱셈
    - 입력 크기: 행과 열의 개수(n)
    - 3중 for 루프가 항상 n번 실행하므로 다음과 같이 계산
    - 시간 복잡도: T(n) = n*n*n = n**3

단위 연산의 실행 횟수는 항상 일정한가?
    - 1.2, 1.3, 1.4의 경우: 항상 일정
    - 1.1(순차 탐색)의 경우: 입력 사례에 따라 다름
        - S = [10,7,11,5,13,8] x = 3 # 6 번
        - S = [10,7,11,5,13,8] x = 5 # 4 번
        - S = [10,7,11,5,13,8] x = 7 # 1 번

입력 사례에 따른 시간 복잡도 분석
    - 일정 시간 복잡도: 입력 사례에 따라 달라지지 않는 경우
    - 최악, 최적, 평균 시간 복잡도 분석: 입력 사례에 따라 달라지는 경우

1.1(순차 탐색)의 시간 복잡도 분석
    - 단위 연산: 리스트의 원소와 주어진 키 x와의 비교 연산
    - 입력 크기: 리스트 원소의 개수(n)
    - 최악의 경우는 모두 비교: W(n) = n
    - 최적의 경우는 모두 비교: B(n) = 1
    - 평균의 경우: 주어진 키 x가 k 번째에 있으면 k 번을 비교함
        - 만약 어떤 키 x는 리스트 S에 골고루 분포해 있다고 한다면,
        A(n) = 어쩌구 시그마 어쩌구저쩌구 = (n+1)/2 = n/2 + 1/2

어떤 알고리즘이 (궁극적으로) 더 빠른가?
    - 시간 복잡도: 입력 크기(n)에 대한 단위 연산 횟수의 함수 f(n)
    - 시간 복잡도가 f1(n) = n 인 알고리즘과 f2(n) = n**2 인 알고리즘
    - 만약 단위 연산의 실행 시간이 f2는 t이고, f1은 1000t일 경우
        - f1의 단위 연산이 f2의 단위 연산보다 1000배 느리지만
        - 알고리즘 전체의 실행 시간은 f1이 n * 1000t, f2는 n**2 * t이므로
        - 부등식 n**2 * t > n * 1000t 이 성립하려면
        - n > 1000
        - 즉, n이 1000보다 크면 f1이 f2보다 궁극적으로 더 빠르다고 할 수 있다. # 차수 차이

차수(Order): 알고리즘의 궁극적인 성능 분류
    - 1차 시간 알고리즘: 시간 복잡도가 1차 함수인 알고리즘
    - 2차 시간 알고리즘: 시간 복잡도가 2차 함수인 알고리즘
    - 근본 원리: 모든 1차시간 알고리즘은 구극적으로 2차 시간 알고리즘보다 빠르다.
    - 따라서, 시간 복잡도 함수의 차수로 알고리즘의 성능을 분류할 수 있다.

    복잡도 함수  |   분류 이름    |   대분류
    ----------------------------------------
        1       |    상수 시간   |       
    -----------------------------
        lgn     |    로그 시간   |       
    -----------------------------
        n       |    선형 시간   |       
    -----------------------------  다항 시간 (polynomial time)
        nlgn    | 선형-로그 시간 |       
    -----------------------------
        n**2    |    2차 시간    |       
    -----------------------------
        n**3    |    3차 시간    |       
    ----------------------------------------
        2**n    |    지수 시간   |       
    -----------------------------  지수 시간 (exponential time)
        n!      |  팩토리얼 시간 |       
    ----------------------------------------