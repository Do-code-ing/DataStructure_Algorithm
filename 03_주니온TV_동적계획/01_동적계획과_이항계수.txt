동적계획법: Dynamic Programming # 이해하면 절반은 넘었다. 이해하는 것도 어렵고 응용도 어렵다.
    - 문제를 더 작은 문제로 분할하되, 상향식으로 문제를 해결한다.
    - 1953년, Richard Bellman 교수가 제안
    - Programming: 여기서는 '계획'을 의미
        - TV프로그램. 오늘 행사의 프로그램 안내 << 와 같은 의미
    - Memoization: 메모이제이션
        - 가장 작은 입력 사례의 해답을 테이블에 저장하고 필요할 때 꺼내 쓴다.

동적계획법으로 문제 풀기
    1. 문제를 해결할 수 있는 재귀 관계식을 구한다. < 점화식을 구한다.
    2. 가장 작은 입력사례로부터 상향식 방법으로 문제를 해결한다.

분할정복법 vs 동적계획법
    - 문제를 작은 사례로 분할하여 해결한다는 점에서 동일
    - 분할정복: 재귀 호출을 통해 분할하여 정복(Top-Down)
    - 동적계획: 메모이제이션을 통해 상향식으로 정복(Bottom-Up)
    - ex) 피보나치 수열

이항 계수 문제
    - 이항 계수의 정의
        - (n)
          (k) = n!/k!(n-k)!, for 0 <= k <= n
        - 문제점: n!, k!의 값은 매우 크기 때문에 계산이 어렵다.
    - 이항 계수의 재귀적 정의: 분할정복(Divide-and-Conquer) (3.1)
        - nCk = n-1Ck-1 + n-1Ck if 0 < k < n else 1 
    
3.1의 문제점
    - 피보나치 항 구하기의 재귀적 방법과 같은 문제
    - 중복 호출을 없앨 수 있는 방법은? 반복적 방법 -> 동적계획법

이항 계수의 성질: 파스칼의 삼각형
        1 
        1 2 1
        1 3 3 1
        1 4 6 4 1
        1 5 10 10 5 1
        1 6 15 20 15 6 1
        1 7 21 35 35 21 7 1
        1 8 28 56 70 56 28 8 1
        1 9 36 84 126 126 84 36 9 1

이항 계수 구하기: 동적계획(Dynamic Programming) (3.2)
    - 1단계: 재귀 관계식을 찾는다.
        - 이항 계수의 재귀적 정의를 찾았다.
        - B[i][j] = B[i-1][j-1] + B[i-1][j] if 0 < j < i else 1
    - 2단계: 상향식 방법으로 해답을 구한다.
        - 파스칼의 삼각형이 가진 특성을 이용한다.
        - B[i][j] = 1, j = 0 or j = 1
        - b[i][j] = B[i-1][j-1] + B[i-1][j], 0 < j < i

이항 계수의 시간 복잡도와 성능 개선
    - 3.2(DP)는 3.1(DC)보다 훨씬 효율적
        - DC의 시간 복잡도 = O(nCk) # 지수 시간, 중복이 많아 비효율적
        - DP의 시간 복잡도 = O(nk) = O(n^2) # 2차 시간

연습문제 3.4: 효율적인 이항계수 계산 (3.3)
    - 다음 성질을 이용하면 성능을 더 개선할 수 있다.
        - nCk = nCn-k: k가 n/2보다 클 경우에 적용
        # nCk를 모두 구하지 않고, 서로 대칭되는 부분이 있으므로, 절반까지만 구하고 나머지도 같다고 출력해버리기.
    - 2차원 리스트를 사용할 필요가 있는가?
        - 1차원 리스트만으로도 구현이 가능하다.
