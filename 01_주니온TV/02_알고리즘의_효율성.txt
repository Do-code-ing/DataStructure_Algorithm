알고리즘의 효율성
    - 알고리즘의 성능: 시간과 공간 사용량의 효율성
    - 알고리즘의 성능은 컴퓨터의 실행 속도나 메모리의 가격에 무관

순차 탐색 vs 이분 검색(이진 탐색: Binary Search)
    - 입력 리스트의 조건에 따른 탐색 알고리즘이 선택
        1. 정렬되지 않은 리스트에서 키 찾기: 순차 탐색 (O(n))
        2. 정렬된 리스트에서 키 찾기: 이분 검색 (O(log2n+1))

이분 검색 (1.5)
    1. 주어진 리스트 S와 키 x에 대해서,
    2. 먼저 x를 리스트의 중앙에 위치한 원소와 비교
    3. 만약 같으면, 찾았으므로 알고리즘을 종료
    4. 만약 x가 그 원소보다 작으면 x는 왼쪽에 있을 것이므로
        - 왼쪽 리스트에 대해서 이진 탐색 실행 (재귀 호출)
    5. 만약 x가 그 원소바다 크면 x는 오른쪽에 있을 것이므로
        - 오른쪽 리스트에 대해서 이진 탐색 실행 (재귀 호출)
    6. 더 이상 찾을 리스트가 없으면 알고리즘을 종료

순차 탐색과 이분 검색 알고리즘의 효율성 비교
    - 순차 탐색: 크기가 n인 리스트에서 n번의 비교를 수행
    - 이분 검색: 크기가 n인 리스트에서 log2 n+1번의 비교를 수행

    리스트의 크기(n)    순차 탐색의 비교 횟수   이분 검색의 비교 횟수
        128                 128                 8
        1,024               1,024               11
        1,048,576           1,048,576           21
        4,294,987,296       4,294,987,296       33

피보나치 수열의 n 번째 항 구하기 (1.6)
    - 피보나치 수열: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...
    - 피보나치 수열의 (재귀적)정의
        - f0 = 0, f1 = 1
        - fn = fn-1 + fn-2, (n>=2)
    - 문제: 피보나치 수열의 n 번째 항을 구하시오
    - 알고리즘: 재귀적 정의를 그대로 구현하면 됨

Algorithm 1.6의 효율성
    - 재귀적 정의 이용: 작성하기도 쉽고 이해하기도 쉬움
    - 그러나 너무 비효율적이다. 왜 그럴까?

Algorithm 1.6의 비효유성을 개선하려면?
    - 같은 값을 중복해서 재귀적으로 계산하지 않도록 해야 함
    - 이미 계산한 피보보나치 항의 값은 리스트에 저장
    - 이미 계산된 피보나치 항은 필요할 때 꺼내쓰면 된다.

연습문제 1.2.1:
    - 1.7에서 리스트 f를 사용하지 않아도 되는가?
    - 만약, 그렇다면 f를 사용하지 않고 반복문으로 피보나치 항을 구하시오.
    