큰 정수의 산술 문제
    - 문제: 특정 컴퓨터/언어가 표현할 수 없는 큰 정수의 산술 연산
    - 가정: 10진수 체계에서의 덧셈과 곱셈

    - 10진수를 소프트웨어적으로 표현하는 방법은?
        - 리스트를 이용하여 각 자리수(digit)를 하나의 원소로 저장
        - 567,832: S = [2,3,8,7,6,5]

큰 정수의 덧셈 (2.9-1)
    - n개의 자릿수(digit) 각각을 더하면서 올림수(carry)를 고려

                1   1   0   0   <- carry
                9   8   7   6
        +           5   4   3
        ----------------------
            1   0   4   1   9

큰 정수의 곱셈: 단순 무식한(Brute-Force) 방법
    - 초등학교에서 배운 방법 T(n) = O(n**2)

                1   2   3
        X           4   5
        ------------------
                6   1   5
        +   4   9   2
        ------------------
            5   5   3   5

큰 정수의 곱셈: 분할정복(Divide-and-Conquer)
    - n개의 자릿수(digit)로 된 숫자를 n/2개의 자릿수로 분할
    - 둘 중 하나의 자릿수는 [n/2]이고, 다른 하나는 [n/2]가 됨

        567,832 = 567 * 10**3 + 832
        6 digits    3 digits    3 digits
        9,423,723 = 9,423 * 10**3 + 723
        7 digits    4 digits        3digits

        u = x * 10**m + y   # m = n/2
        n   n/2         n/2
    
자릿수가 분할된 두 정수의 곱셈 (2.9-2)
    - 두 개의 정수 u, v를 분할하여 곱셈 연산을 함

        u = x * 10**m + y
        v = w * 10**m + z

        uv = (x * 10**m + y)(w * 10**m + z)
            = xw * 10**2m + (xz + yw) * 10**m + yz

큰 정수의 지수 곱셈과 나눗셈 (2.9-3)
    - 10의 지수 m으로 곱하기
        - 왼쪽으로 m 자릿수만큼 쉬프트
    - 10의 지수 m으로 나눈 나머지와 몫
        - 1의 자리에서 m의 자리까지가 나머지
        - m + 1에서 n의 자리까지가 몫

        567,832에 대해
        567 * 10**3 = 567,000
        567,832 div 10**3 = 567
        567,832 rem 10**3 = 832

임계값과 단순 곱셈 (2.9-4)
    - 임계값(threshold): 특정 자리수까지 (threshold = 1)
    - 단순 곱셈: 전통적인 방법으로 곱셈

큰 정수의 곱셈 알고리즘으로 우리가 한 일은?
    - 기본 연산: 한 자릿수에서의 단위 연산(총 m번 실행)
    - 입력 크기: 두 정수의 자릿수(n개의 자릿수)
    - 최선/최악/평균
        - 최악의 경우 두 정수에 모두 0이 하나도 없을 때
    - 2.9의 시간 복잡도 분석:
        - prod() 함수에서 재귀 호출을 네 번 한다는 것에 주목
        - W(s) = 0, W(n) = 4W(n/2) + cn
        - w(n) = O(nlog24) = O(n**2)
    
    - 여긴 어디? 나는 누구?: 우리는 지금까지 뭘 한 걸까?
        - 단순 무식법도 O(n**2)인데 왜 이것도 O(n**2)이냐...
        - 사실 우리는 분할정복에 대해 공부한거다 ㅋㅋㄹㅃㅃ~!

2.9의 효율성 개선 (2.10)
    - 재귀 호출을 4번이나 하니까 효율성이 개선될 수 없다.
    - 재귀 호출의 횟수를 줄일 수는 없을까?

        uv = xw * 10**2m + (xz + yw) * 10**m + yz
        r = uv = (x+y)(w+z) = xw + (xz + yw) + yz
            r = (x+y)(w+z)
            (xz + yw) = r - (xw+yz)
            
            xw      xz+yw       yz 3번의 곱셈으로 완수

prod2()의 시간 복잡도는?
    - 재귀 호출의 숫자를 3회로 줄임
    - W(n) == O(n**1.58) < O(n**2)