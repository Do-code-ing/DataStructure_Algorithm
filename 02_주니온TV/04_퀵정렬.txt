퀵 정렬: 분할 정복(Divide-and-Conquer)
    - 내부(in-place)정렬: 추가적인 리스트를 사용하지 않는 정렬
    - 추가적으로 리스트를 생성하지 않고 정렬할 수 없을까?
        - Hoare(1962), Quick Sort Algorithm

    - Quick-Sort (2.6)
        - [Divide] 기준 원소(pivot)를 정해서 기준 원소를 기준으로 좌우로 분할
        - [Conquer] 왼쪽 리스트와 오른쪽 리스트를 각각 재귀적으로 퀵 정렬
        - [Obtain] 정렬된 리스트를 리턴

기준 원소(pivot)는 어떻게 정할까?
    - 편의상, 리스트의 첫 원소를 기준원소로 정하자

    15 22 13 27 12 10 20 25 
    pivot = 15
    (10 13 12) 15 (22 27 20 25)
    pivot 10, 22
    10 (13 12) 15 (20) 22 (27 25)
    pivot 13, 27
    10 (12) 13 15 20 22 (25) 27

기준 원소로 어떻게 리스트를 나눌까? (2.7)
    - 두 개의 인덱스(i,j)를 이용해서 비교(compare)와 교환(swap)
    
    pivotpoint = partition(S, low=0, high=7)

partition() 함수의 다른 구현 방법 (2.7-1) # 실제로는 이렇게 더 많이 쓰인다.
    
    S = [26, 5, 37, 1, 61, 11, 59, 15, 48, 19]
    pivot = 26
    i = 5
    j = 19
    2.7-1은 pivot과 i는 처음부터 j는 마지막부터 찾으면서 비교 후 스왑
    2.7은 pivot과 순차적으로 증가하는 i와 j를 비교 후 스왑