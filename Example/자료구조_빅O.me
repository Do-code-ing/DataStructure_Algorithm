자료구조, 알고리즘
자료 : data -> 저장공간(memory) + 연산(읽기, 쓰기, 삽입, 삭제, 탐색) = 구조
알고리즘 : 입력(data)을 가지고 유한한 횟수의 연산들을 반복해서 정답을 출력

자료구조의 예 :
1.  변수(variable)
        a = 5 < 쓰기 연산
        print(a) < 읽기 연산
    변수 이름으로 접근

2.  배열(array)
    리스트(list)
        A = [3,-1,5,7]
        3   -1  5   7
        A[0]A[1]A[2]A[3]
    접근 : 원소의 index
    읽기, 쓰기 : A[3]
    삽입 : A.append(9), A.insert()
    삭제 : A.pop(), A.pop(2)

----

자료구조와 알고리즘 성능1 : 가상 컴퓨터 + 가상 언어 + 가상 코드

자료구조+알고리즘 -> 코드 -> HW/SW 환경 상이 (!), 다양한 크기 입력에서 문제 발생

- 가상 컴퓨터와 가상 언어, 가상 코드를 만들어 제약없이 실행하게 한다.


시간복잡도 구하기
1. 모든 입력에 대해 기본연산 횟수를 더한 후 평균 > 현실적으로 불가능
2. 가장 안좋은 입력(worstcase input)에 대한 기본연산 횟수를 측정 : Worstcase Time Complexity
    > 어떤 입력에 대해서도 W.T.C보다 수행시간이 크지 않다라는 보장.

알고리즘 수행시간 = 최악의 입력에 대한 기본연산 횟수

--------

Big-O 표기법 :
알고리즘의 수행시간 = 최악의 경우의 입력에 대한 기본연산 횟수
T1(n) = 2n-1
T2(n) = 4n+1
T3(n) = 3n**2/3 + 3n/2 + 1

T1, T2 : n에 대해 선형적으로 증가 -> 최고차항 n
T3 : 제곱으로 증가 -> 최고차항 n**2
증가율에 차이가 생긴다.

Big-O 표기법이란, 최고차항만을 가지고 수행시간을 표기하려하는 것, 증가율 관점

T1(n) = O(n)으로 표기 가능.
T2(n) = O(n)
T3(n) = O(n**2)

1. 최고차항만 남긴다.
2. 최고차항 계수(상수)는 생략한다.
3. Big-O(최고차항)으로 표기한다.

집합으로 이해하기 :
T1(n) = O(n)
T2(n) = O(n)
T1(n)과 T2(n)은 집합 O(n) = {...}의 원소다

