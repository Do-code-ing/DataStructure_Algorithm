# 재귀 (Recursion) : 
# 재귀 함수 = 함수 내부에서 한 번 이상 자신의 함수를 호출하는 함수
# 재귀 알고리즘 = 알고리즘 내부에서 한 번 이상 자신의 알고리즘을 다시 적용하는 알고리즘
# 재귀 함수의 시간 복잡도는,
# T(n) = O(n)

# 예1. (재귀 함수를 한 번 호출했을 때)
# 1 + 2 + ... + n
# sum(n) = 1 + 2 + ... + (n-1) + n
#        = sum(n-1) + n

def sum1(n):
    if n == 1:
        return n
    return sum1(n-1) + n

print(sum1(4))
# sum1(4) = sum1(3) + 4
#           sum1(2) + 3
#           sum1(1) + 2
#           1
# 재귀 호출과 returns

# 재귀 함수의 수행시간 T(n)은 T(n)에 관한 점화식으로 표현된다.
# 수행시간 T(n) = T(n-1) + c
#              = (T(n-2) + c) + c
#              = T(n-2) + 2c
#                   ...
#                   ...
#              = T(n-(n-1)) + (n-1)c
#              = T(1) + (n-1)c

# c : 상수 (1,2,3 ...)

# 어쩄뚠 O(n)

# 1. n == 1 테스트 : 바닥 조건 (base case) -> T(1) = 1 or c
# 2. 재귀 호출 : T(n) = 점화식
# 3. 1을 전개한 점화식 즉, T(n) = O(n)이 된다.

# 예2. (재귀 함수를 두 번 호출했을 때)
# sum(a, b) = a + (a+1) + ... + (b-1) + b (if a <= b)
# sum(3, 8) = 3 + 4 + 5 + 6 + 7 + 8
#             sum(3, 7) + 8 이렇게 하지 말고,
#            ( 3 + 4 + 5 ) + ( 6 + 7 + 8 )
#              sum(3, 5)        sum(6, 8)
#                 5 = (3+8)/2

def sum2(a, b):
    if a == b:
        return a
    elif a > b:
        return 0
    else:
        m = (a+b)//2
        return sum2(a, m) + sum2(m+1, b)

# T(n) = 2*T(n/2) + c
# T(1) = c
# 즉, T(n) = 2*T(n/2) + c (n=2**k)
#          = 2(2*T(n/2**2) + c) + c
# 시간복잡도 넘 어려웡

# 예3.
# reverse 함수
# A = [1,2,3,4,5] -> [5,4,3,2,1]

# 너무 빢쳐용 ㅜ.ㅜ